# Waf Conan Generator

Makes it possible to use Conan packages in your Waf projects (WIP)

It consists of:

1. A custom waf tool (`conan.py`)
2. A set of waf-specific generators (`WafDeps.py` and `WafToolchain.py`)

It fully supports cross compilation and Conan profiles (docs pending)

## Usage

Check the `tests` folder for some complete example projects.

You need to include the `conan.py` tool somehow in your projects, either
alongside the waf script, or embedded in your waf distribution. [See here]
(https://waf.io/book/#_customization_and_redistribution) for more details.

After calling `conan install ...`, simply load the 'conan' tool in your
`configure` method like any other waf tool, then call the method
`conf.load_conan()`. This will use the output of the Conan generators to
populate the config environment with waf *use variables*. (Refer to [Table 1 of
section 10.3.3](https://waf.io/book/#_foreign_libraries_and_flags) of the waf
book).

For advanced use cases, you can pass the following parameters to `load_conan()`:

* `env`: the Waf environment object to populate
* `conan_deps`: the file generated by the `WafDeps` generator
* `conan_toolchain`: the file generated by the `WafToolchain` generator

This is useful if you're cross compiling, and need to manage multiple
environments separately, call conan install in different output folders for
each target architecture, etc.

### Using libraries in your wscripts

The exact *'use names'* (i.e. the strings you pass to the `use` attribute of
task generators in your wscripts to link with a library) aren't the same as
Conan's package/component names. This is done for compatibility with how waf's
environment keys work.

You can see all the available *use names* when you call `waf configure`. This
will print the full list of all available names, **including transient
dependencies** and [package components]
(https://docs.conan.io/2/examples/conanfile/package_info/components.html). 

You **must** pass the `conan` feature to your build generators, otherwise you
will get link/compile errors due to missing transient dependencies. Example:

```
def build(bld):
	#BAD: fails because spdlog depends on fmt, which is missing from `use` list
	bld(
		features = ['cxx', 'cxxprogram'],
		use = ['spdlog'], #adding 'fmt' here fixes it, but don't do that
		source = 'main.cpp',
		target = 'my-app')
	
	#GOOD: the 'conan' feature will add all transient dependencies automatically
	bld(
		features = ['cxx', 'cxxprogram', 'conan'],
		use = ['spdlog'],
		source = 'main.cpp',
		target = 'my-app')
```

In the first generator, the program won't build unless you add 'fmt' to the
`use` attribute, since 'spdlog' requires it. This is obviously a bad idea
since 'fmt' is just a transient dependency of your program, and you shouldn't
try to track those manually. Instead, the 'conan' feature in the second
generator will do this automatically. 

If you do need to use 'fmt', then you shoud add it as an explicit dependency in
your conanfile, and not simply assume that it will be present as a transient.